# Xreamier Technichal Report

### Goals and Results
---------

![This figure did not load](https://github.com/FreakingBarbarians/FreakingBarbarians_Images/blob/master/MicroservicesDiagram.png?raw=true)

The progress on each of these systems are marked in the following. We use an asterkisk(*) to denote our goal, and we use three exclamations(!!!) to denote milestones that are complete.

|WebPage| Authentication | Ticketing Server | Email Notification Service | PostgresDB |CSV Exporter|
|---------| ---- | ---- | ---- | ---- | ---- |
|Landing Page Setup!!!| Credentials Setup!!!| Ticket Creation!!!| Notifications Complete!!!|Setup SQL Schema!!!| Exportable CSV|
| Dashboards | Authentication for Different Users| Ticket Status Changes*!!! | Notifications Tested!!! | Setup DB!!!| Tested & Verified CSV Format|
|To Do Lists | Operation Support for Different Users*| Ticket Notes | | DB Tested*!!!| |
|Web Pages Tested | Authentication Tested| Tickets Tested | | | |

**Rationale**
We chose these services because we believed it would give us a good idea of the functionality of our MVP. Recall that in our scope we wanted something that handled, with a good degree of fidelity, the relationships and behaviors of tickets.

>>>Because of this we decided that we wanted to build the systems that would facilitate ticket creation,  assignment, and management before anything else.

From this we decided that the Ticketing Server, Authentication, and the PostgresDB were the three microservices that needed to be completed first.

**Results & Analysis**
We met most of our goals and were able to even complete some extra services along the way. Below is a detailed analysis of what happened.

*DB/Ticketing/WebPage/Email Notification*
We realized that the ticketing service was done mostly by designing a good schema. The mutation of tickets is then very simple, a simple sql query. Because of this, after creating the DB microservice we had a very easy time implementing the Ticketing Server. Then we had some extra time to work on other services such as the WebPage and the Email Notification Service. 

*WebPage*
We managed to find a generic template that was very much in-line with the vision we had of what our front-end would look like so we took it and modified it a bit.

*Authentication*
We found that authentication did not meet its goal because supporting operations and levels of authentication for different users is difficult and required us to modify our schema to give operation permissions for each user. This set us back enough that we could not finish this milestone. As well implementing this requires some permission integer fields and bitmasking. We have not yet agreed on a convention so we must do that first, i.e. decide what bits indicate what permissions the user has.

## High Level Overview
---
![This figure did not load](https://github.com/FreakingBarbarians/FreakingBarbarians_Images/blob/master/MicroservicesDiagram.png?raw=true)

Our service is split into many microservices that communicate with eachother. We designed it this way to keep our service modular. Below we touch upon some of the more important aspects of our service.

**Object Relational Model**
The object relational model is very much at the center of our service. Using it we can use the abstract idea of a ticket to mutate the database. We use Sequelize, Sequelize Migration, and SQL Alchemy to implement the ORM. Sequelize allows us to create objects who's mutators are linked to SQL queries. Sequelize migration allows us to dynamically update the PostgresDB whenever a mutation happens. Upon the instantiation of an object it undergoes a validation phase that ensures the object's fields are up-date, mutating the database when necessary. This allows us to have a powerful way of reasoning about tickets and users, and makes writing code using it much easier.

```
User.findOne({
            where: {
                username: username
            }
```

Taken from [passport.js](https://github.com/csc302-winter-2018/proj-Xreamier/blob/master/services/PGDB/src/config/passport.js), the above is a select statement in sequelize that checks if a username exists in the DB. Very clean and very easy to understand.

**Database Service**
The database service uses the ORM to serve database requests. Currently we have the database autogenerated on the local disk, we have plans to move it into the cloud in the future.

The following snippets are taken from [index.js](https://github.com/csc302-winter-2018/proj-Xreamier/blob/master/services/PGDB/src/models/index.js)
```
fs
    .readdirSync(__dirname)
    .filter(file =>
        (file.indexOf('.') !== 0) &&
        (file !== basename) &&
        (file.slice(-3) === '.js'))
    .forEach(file => {
        const model = sequelize.import(path.join(__dirname, file));
        db[model.name] = model;
    });
```
Here Sequelize is importing a database stored on the filesystem (fs).
Below, we see Sequelize associating the objects to their tables using their modelnames.
```
Object.keys(db).forEach(modelName => {
    if (db[modelName].associate) {
        db[modelName].associate(db);
    }
});
```
In implementing this database we had to describe how the mutators related to SQL queries. This description allows us to re-use sql queries as if they were mutators of an object.

From, [tickets.js](https://github.com/csc302-winter-2018/proj-Xreamier/blob/master/services/PGDB/src/models/ticket.js)
```
'use strict';
module.exports = (sequelize, DataTypes) => {
    var Ticket = sequelize.define('Ticket', {
        status: DataTypes.INTEGER
    }, {});
    Ticket.associate = function(models) {};
    return Ticket;
};
```
This description allows Sequelize Migrate to autogenerate functions that handle the SQL mutation.
From [20180316195258-create-ticket.js](https://github.com/csc302-winter-2018/proj-Xreamier/blob/master/services/PGDB/src/migrations/20180316195258-create-ticket.js) (an autogenerated file)
```
'use strict';
module.exports = {
    up: (queryInterface, Sequelize) => {
        return queryInterface.createTable('Tickets', {
            id: {
                allowNull: false,
                autoIncrement: true,
                primaryKey: true,
                type: Sequelize.INTEGER
            },
            status: {
                type: Sequelize.INTEGER
            },
            createdAt: {
                allowNull: false,
                type: Sequelize.DATE
            },
            updatedAt: {
                allowNull: false,
                type: Sequelize.DATE
            }
        });
    },
    down: (queryInterface, Sequelize) => {
        return queryInterface.dropTable('Tickets');
    }
};
```

This service also has a quickstart guide [here](https://github.com/csc302-winter-2018/proj-Xreamier/tree/master/services/PGDB).

**Authentication**
The gateway to other endpoints. The client will send all routes through the auth service to verify priveliges. The auth service communicates with all other services in order to start the communcations that will serve requests. The auth service is implemented using Express, NodeJs, and Passport for auth services. The service communicates with the DB service and the Ticketing service using Sequelize ORM models.

We use the Passport third party framework to handle authentication. Here are some examples of the routes used for signup and login from [api_authentication.js](https://github.com/csc302-winter-2018/proj-Xreamier/blob/master/services/AUTH/src/routes/api_authentication.js)
```
    router.post('/signup', passport.authenticate('local-signup'), (req, res) => {
        res.sendStatus(200);
    });

    router.post('/login', passport.authenticate('local-signin'), (req, res) => {
        res.sendStatus(200);
    });
```

Any post must go through this function that checks if the user is logged in. In future iterations we will provide support for different levels of authentication and different operation priveliges. From [util.js](https://github.com/csc302-winter-2018/proj-Xreamier/blob/master/services/AUTH/src/routes/api_util.js).

```
function isLoggedIn(req, res, next) {
    if (req.isAuthenticated()) {
        return next();
    } else {
        res.sendStatus(401);
    }
}
```

The authentication function (local-signin) is too long to put in here but it can be found [here](https://github.com/csc302-winter-2018/proj-Xreamier/blob/master/services/PGDB/src/config/passport.js).

This service also has a quickstart guide [here](https://github.com/csc302-winter-2018/proj-Xreamier/tree/master/services/AUTH).

**Ticketing Service**
The ticketing service is responsible for all ticket mutation. All ticket requests come from the Auth service.

In keeping with the ORM model we needed to re-implement the ORM to be compatible with python. To facilitate this we used SQL Alchemy. Below are some definitions of a ticket using SQL Alchemy from [models.py](https://github.com/csc302-winter-2018/proj-Xreamier/blob/master/backend/models.py).

```
class Ticket(Base):
    __tablename__ = 'Tickets'
    id = Column(Integer, primary_key=True)
    status = Column(Integer)
    createdAt = Column(Date, nullable=False)
    updatedAt = Column(Date, nullable=False)
```
Afterwards the ticket mutation functions are very simple and straightforward. From [routes.py](https://github.com/csc302-winter-2018/proj-Xreamier/blob/master/backend/routes.py)
```
@app.route('/portal/ticket/<int:ticket_id>', methods=['GET'])
def get_ticket(ticket_id):
    try:
        sess = connect_db("csc302", "csc302isfun", "gradapp")
        result = sess.query(Ticket).filter_by(id=ticket_id).first()
        if result is None:
            return "No ticket with id " + str(ticket_id)
        else:
            return "Found ticket. id: " + str(result.id) + " status: " + str(result.status)
    except:
        abort(500)
```
The rest of the routes can be found in the same file. The service also has a quickstart guide [here](https://github.com/csc302-winter-2018/proj-Xreamier/tree/master/backend).

**Website**
The website is very minimal right now since it was not our main focus this iteration. But we did manage to whip up a template and modify it to give us a non-interactive prototype. We used the [Material Dashboard](https://github.com/creativetimofficial/material-dashboard-react.git) public template from github.

![This figure did not load](https://github.com/FreakingBarbarians/FreakingBarbarians_Images/blob/master/CSC302_FrontEnd_1.png?raw=true)
![This figure did not load](https://github.com/FreakingBarbarians/FreakingBarbarians_Images/blob/master/CSC302_FrontEnd_2.png?raw=true)

**Email Service**
We also implemented an email service that automatically notifies the owners of each ticket when specific things happen. The service is implemented using SparkHost.

Below is a code snippet from [api_email.js](https://github.com/csc302-winter-2018/proj-Xreamier/blob/master/services/MAILINATOR/routes/api_email.js)
```
router.post('/email/ticket', (req, res) => {
        client.transmissions.send({
                options: {
                    sandbox: true
                },
                content: {
                    from: 'hello@sparkpostbox.com',
                    subject: 'Ticket Updated ' + req.body.ticket_id,
                    html: "<html>" +
                        "   <body>" +
                        "     <p>Hi " + req.body.username + ",</p>" +
                        "     <p>We're notifying you that your ticket " + req.body.ticket_id + " has been updated!" +
                        "     <p>Cheers,<br>" +
                        "     The Graduate Applications Team<br>" +
                        "     </p>" +
                        '   </body>' +
                        '</html>'
                }, ...
```

Here is the email produced by the above.

![This figure did not load](https://github.com/FreakingBarbarians/FreakingBarbarians_Images/blob/master/CSC302_Ticket.jpg?raw=true)

**Testing**
We created unit tests to help us verify the correctness of our code. For services implemented in node we used Mocha and Chai to unit test, for services implemented in python we used unittest.

Below is test code from [ticket_routes_tests.py](https://github.com/csc302-winter-2018/proj-Xreamier/blob/master/backend/ticket_routes_tests.py) and [auth_test.js](https://github.com/csc302-winter-2018/proj-Xreamier/blob/master/services/AUTH/test/auth_test.js#L54) respectively.
```
    # Request a ticket id that does exist in the system.
    def test_get_ticket_that_exists(self):
        ticket = Ticket(id=3, status=7, createdAt=datetime.date.today(), updatedAt=datetime.date.today())
        self.session.add(ticket)
        self.session.commit()

        # Verify the ticket was added to the db.
        check = self.session.query(Ticket).filter_by(id=3).first()
        assert check is not None

        response = self.app.get('/portal/ticket/3')
        assert response.data == "Found ticket. id: 3 status: 7"
        self.clean_up(ticket)
```
```
    describe('POST /login', () => {
        it('it should login a pre-registered user.', (done) => {
            chai.request(server)
                .post('/login')
                .send(account_details)
                .end((err, res) => {
                    res.should.have.status(200);
                    done();
                });
        });
```

## Technical Highlights

---

We will now iterate over several interesting things that happened during our iteration that gave us insight into how well we were operating as a team.

**Discord & Discord -> Github Integration**
We found that using discord as our main choice of communcation was a very good decision, especially since Daniel Chan was able to integrate a github bot that let us know whenever something happened in the repo. This way we get instant notifcation and response times to pull requests (and just anything in general) was a lot faster. We will continue using Discord.

![This figure did not load](https://github.com/FreakingBarbarians/FreakingBarbarians_Images/blob/master/302_discord.png?raw=true)

**Team Communication**
Overall our team communcation is really great. I think this is mostly due to using discord, and everyone being interested and working towards the project equally.

![This figure did not load](https://github.com/FreakingBarbarians/FreakingBarbarians_Images/blob/master/CSC302_communication.png?raw=true)

**Github Projects & Tracking Progress**
Although github projects is a useful means of tracking tasks, we were more interested in working on the tasks and book-keeping was not done as much as it should have been. For the next iteration it would help to be more conscious of this book-keeping as it helps us track progress. For example, when writing this report, I could not just go to a page and see what was done. I had to go through source code and ask a bunch of people.

![This figure did not load](https://github.com/FreakingBarbarians/FreakingBarbarians_Images/blob/master/CSC302_ghubprojects.png?raw=true)

**Peer Reviews, Pull to Task Ratio, Buddy System**
Overall our Pull to Task ratio is very good, we never push directly to master. One of the first things we did was revoke master commit priveliges, forcing everything to be a pull request. This in turn forced us to do peer reviews which has helped us catch many bugs and typos. Unfortunately the buddy system devised in Collab was not really very helpful (due to scheduling in an academic setting), as a result we ended up just reviewing whatever pull request we could, when we could. The system as is works very well even without the buddy system so we will continue without it.

![This figure did not load](https://github.com/FreakingBarbarians/FreakingBarbarians_Images/blob/master/CSC302_branches.png?raw=true)

Here are some pull requests.

https://github.com/csc302-winter-2018/proj-Xreamier/pull/22

https://github.com/csc302-winter-2018/proj-Xreamier/pull/4

https://github.com/csc302-winter-2018/proj-Xreamier/pull/2

**Setting up Docker**
Setting up docker was difficult since we needed to do it on several OS's and it needed different steps for each OS. We also tried clustering with Docker Swarm but since the IP addresses are DHCP (i.e. dynamic) we ran into the problem of dynamically resolving each node's IP and we decided it was out of the scope of our first iteration.

**Sprints & Time Management**
Originally we had two sprints planned out, one for DB and one for the ticketing server as well as authentication. We realized very quickly that it was difficult to get people to work on these systems during the sprint because of the academic setting (other assignments taking priority, midterms, etc). As a result we abandoned the sprints and did most of the work in the week leading up to the P2 deadline. For the next iteration most of the assignments and midterms should be done so managing our time will be easier.

**Unit Testing**
We used Mocha, Chai and unittest to facilitate unit testing on our microservices.   This helped development greatly as it allowed us to find bugs very quickly and verify merge requests. In the future we can even integrate this with Travis CI.

![This figure did not load](https://github.com/FreakingBarbarians/FreakingBarbarians_Images/blob/master/302_DB_TEST.png?raw=true)

**ORM**
The ORM is a powerful way of encapsulating SQL queries into an abstract object. This is especially helpful for tickets. One of the problems we had was getting everyone to have the mental paradigm shift from standard SQL queries to the ORM. Daniel Chan, the resident expert on ORM spent many hours explaining ORM to us.

One of the interesting bugs we had with ORM was that, when instantiating a new object the ORM framework automatically creates the fields. Our ticket creation was creating the fields an additional time manually which caused an internal server error. This was fixed after realizing the issue.

## Next Iteration

---

**Phase 3**

|WebPage| Authentication | Ticketing Server | Email Notification Service | PostgresDB |CSV Exporter|
|---------| ---- | ---- | ---- | ---- | ---- |
|Landing Page Setup| Credentials Setup| Ticket Creation| Notifications Complete|Setup SQL Schema| Exportable CSV|
| Dashboards | Authentication for Different Users| Ticket Status Changes | Notifications Tested* | Setup DB| Tested & Verified CSV Format*|
|To Do Lists | Operation Support for Different Users| Ticket Notes | | DB Tested*| |
|Web Pages Tested* | Authentication Tested* | Tickets Tested* | | | |

For phase 3 we hope to have all the milestones completed, so we may begin properly integrating the systems with eachoter for the final demo, as well as write a comprehensive test suite that ensures the service functions properly as a whole.

For this phase we will have completed all the functionality for each of the microservices and will spend most of the time connecting the components together, figuring out routes, and polishing the UI where applicable. We are also integrating the microservices with eachother on the fly so we hope to have a lot of time in this iteration for inevitable spillover from the previous iterations.

